// security_hash_exploits_test.go: tests for hash calculation functionality in security validation
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira library
// SPDX-License-Identifier: MPL-2.0

package goplugins

import (
	"os"
	"strings"
	"testing"
	"time"
)

// TestCalculateFileHash_ResourceExhaustion_LargeFiles verifies Dos protection against huge files
// Potential bug: memory exhaustion, infinite loops, performance degradation
func TestCalculateFileHash_ResourceExhaustion_LargeFiles(t *testing.T) {
	config := SecurityConfig{
		Enabled:       true,
		HashAlgorithm: HashAlgorithmSHA256,
		Policy:        SecurityPolicyStrict,
	}

	validator, err := NewSecurityValidator(config, &testLogger{t: t})
	if err != nil {
		t.Fatalf("Failed to create SecurityValidator: %v", err)
	}

	t.Run("LargeFile_PerformanceLimit", func(t *testing.T) {
		// Create 50MB file to test performance
		tmpFile, err := os.CreateTemp("", "large_hash_test_*.bin")
		if err != nil {
			t.Fatalf("Failed to create temp file: %v", err)
		}
		defer func() {
			if err := os.Remove(tmpFile.Name()); err != nil {
				t.Logf("Warning: Failed to remove temp file %s: %v", tmpFile.Name(), err)
			}
		}()

		largeSize := int64(50 * 1024 * 1024) // 50MB
		if err := createFileWithSize(tmpFile.Name(), largeSize); err != nil {
			t.Fatalf("Failed to create large file: %v", err)
		}

		// calculateFileHash should complete in reasonable time (< 5 seconds for 50MB)
		start := time.Now()
		hash, err := validator.calculateFileHash(tmpFile.Name())
		duration := time.Since(start)

		if err != nil {
			t.Errorf("calculateFileHash failed for large file: %v", err)
		}
		if hash == "" {
			t.Error("Got empty hash for large file")
		}

		// Performance check: no more than 5 seconds for 50MB
		if duration > 5*time.Second {
			t.Errorf("calculateFileHash too slow for 50MB file: %v", duration)
		}
	})

	t.Run("EmptyFile_EdgeCase", func(t *testing.T) {
		// Test empty file (common edge case)
		tmpFile, err := os.CreateTemp("", "empty_hash_test_*.bin")
		if err != nil {
			t.Fatalf("Failed to create temp file: %v", err)
		}
		defer func() {
			if err := os.Remove(tmpFile.Name()); err != nil {
				t.Logf("Warning: Failed to remove temp file: %v", err)
			}
		}()
		if err := tmpFile.Close(); err != nil {
			t.Fatalf("Failed to close temp file: %v", err)
		}

		hash, err := validator.calculateFileHash(tmpFile.Name())
		if err != nil {
			t.Errorf("calculateFileHash failed for empty file: %v", err)
		}

		// Empty file should have consistent hash
		expectedEmptyHash := "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" // SHA256 di stringa vuota
		if hash != expectedEmptyHash {
			t.Errorf("Empty file hash incorrect. Expected: %s, Got: %s", expectedEmptyHash, hash)
		}
	})

	t.Run("NonexistentFile_ErrorHandling", func(t *testing.T) {
		// Test nonexistent file
		nonExistentPath := "/tmp/definitely_does_not_exist_" + randomString(10) + ".bin"

		hash, err := validator.calculateFileHash(nonExistentPath)
		if err == nil {
			t.Error("calculateFileHash should fail for nonexistent file")
		}
		if hash != "" {
			t.Errorf("Expected empty hash for nonexistent file, got: %s", hash)
		}
	})
}

// TestCalculateFileHash_PathTraversal_SecurityBypass verifies protection against path traversal
// Potential bug: access to files outside whitelist, directory traversal attacks
func TestCalculateFileHash_PathTraversal_SecurityBypass(t *testing.T) {
	config := SecurityConfig{
		Enabled:       true,
		HashAlgorithm: HashAlgorithmSHA256,
		Policy:        SecurityPolicyStrict,
	}

	validator, err := NewSecurityValidator(config, &testLogger{t: t})
	if err != nil {
		t.Fatalf("Failed to create SecurityValidator: %v", err)
	}

	// Test various path traversal attempts
	pathTraversalAttempts := []struct {
		name string
		path string
		desc string
	}{
		{
			name: "BasicDotDot",
			path: "../../../etc/passwd",
			desc: "Basic dot-dot path traversal",
		},
		{
			name: "DotDotWithClean",
			path: "./../../etc/passwd",
			desc: "Path traversal that might pass filepath.Clean",
		},
		{
			name: "WindowsStyleTraversal",
			path: "..\\..\\..\\windows\\system32\\config\\sam",
			desc: "Windows-style path traversal",
		},
		{
			name: "AbsolutePath",
			path: "/etc/passwd",
			desc: "Absolute path outside working directory",
		},
	}

	for _, tt := range pathTraversalAttempts {
		t.Run(tt.name, func(t *testing.T) {
			hash, err := validator.calculateFileHash(tt.path)

			// Should fail for path traversal (security)
			if err == nil {
				t.Errorf("%s: calculateFileHash should reject path traversal attempt: %s", tt.desc, tt.path)
			}
			if hash != "" {
				t.Errorf("%s: Expected empty hash for path traversal, got: %s", tt.desc, hash)
			}

			// Verify that the error indicates a path problem
			if err != nil && !strings.Contains(err.Error(), "path") && !strings.Contains(err.Error(), "invalid") {
				t.Errorf("%s: Error should indicate path problem, got: %v", tt.desc, err)
			}
		})
	}
}

// TestCalculateFileHash_SpecialFiles_SystemFiles verifies handling of special system files
// Potential bug: infinite hang on /dev/random, /dev/zero, named pipes, device files
func TestCalculateFileHash_SpecialFiles_SystemFiles(t *testing.T) {
	config := SecurityConfig{
		Enabled:       true,
		HashAlgorithm: HashAlgorithmSHA256,
		Policy:        SecurityPolicyStrict,
	}

	validator, err := NewSecurityValidator(config, &testLogger{t: t})
	if err != nil {
		t.Fatalf("Failed to create SecurityValidator: %v", err)
	}

	// Test special files that could cause issues
	specialFiles := []struct {
		name          string
		path          string
		desc          string
		shouldTimeout bool
	}{
		{
			name:          "DevNull",
			path:          "/dev/null",
			desc:          "Should handle /dev/null gracefully",
			shouldTimeout: false,
		},
		{
			name:          "DevZero",
			path:          "/dev/zero",
			desc:          "Should not hang on infinite /dev/zero",
			shouldTimeout: true, // /dev/zero is infinite
		},
	}

	for _, tt := range specialFiles {
		t.Run(tt.name, func(t *testing.T) {
			// Check if the file exists (not all systems have these device files)
			if _, err := os.Stat(tt.path); os.IsNotExist(err) {
				t.Skipf("Special file %s not available on this system", tt.path)
			}

			// Test with timeout to avoid infinite hangs
			done := make(chan bool)
			var hash string
			var hashErr error

			go func() {
				hash, hashErr = validator.calculateFileHash(tt.path)
				done <- true
			}()

			select {
			case <-done:
				if tt.shouldTimeout {
					// /dev/zero should be handled without reading infinitely
					t.Logf("%s: Function completed with hash=%s, err=%v", tt.desc, hash, hashErr)
				} else {
					t.Logf("%s: Completed normally with hash=%s, err=%v", tt.desc, hash, hashErr)
				}
			case <-time.After(2 * time.Second):
				if !tt.shouldTimeout {
					t.Errorf("%s: calculateFileHash timed out - possible infinite read", tt.desc)
				} else {
					t.Logf("%s: Timed out as expected for infinite file", tt.desc)
				}
			}
		})
	}
}

// Helper function to generate random strings
func randomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyz0123456789"
	result := make([]byte, length)
	for i := range result {
		result[i] = charset[i%len(charset)]
	}
	return string(result)
}
