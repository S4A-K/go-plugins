name: Documentation

on:
  push:
    branches: [ main ]
    paths:
      - '**.go'
      - 'docs/**'
      - '.github/workflows/docs.yml'
  pull_request:
    branches: [ main ]
    paths:
      - '**.go'
      - 'docs/**'

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      HUGO_VERSION: 0.120.0
    steps:
      - name: Install Hugo CLI
        run: |
          wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \
          && sudo dpkg -i ${{ runner.temp }}/hugo.deb          
          
      - name: Install Dart Sass
        run: sudo snap install dart-sass
        
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
          
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
          
      - name: Install gomarkdoc
        run: go install github.com/princjef/gomarkdoc/cmd/gomarkdoc@latest
        
      - name: Generate API documentation
        run: |
          # Generate API reference from GoDoc comments
          gomarkdoc --output docs/content/api/_index.md .
          
          # Generate individual package documentation
          for pkg in $(go list ./...); do
            pkg_name=$(basename $pkg)
            mkdir -p docs/content/api/$pkg_name
            gomarkdoc --output docs/content/api/$pkg_name/_index.md $pkg
          done
          
      - name: Validate documentation examples
        run: |
          # Create validation script
          cat > validate-docs.go << 'EOF'
          package main
          
          import (
              "fmt"
              "go/ast"
              "go/parser"
              "go/token"
              "io/fs"
              "os"
              "path/filepath"
              "regexp"
              "strings"
          )
          
          func main() {
              err := filepath.WalkDir("docs/content", func(path string, d fs.DirEntry, err error) error {
                  if err != nil || !strings.HasSuffix(path, ".md") {
                      return err
                  }
                  return validateCodeBlocks(path)
              })
              if err != nil {
                  fmt.Printf("Validation failed: %v\n", err)
                  os.Exit(1)
              }
              fmt.Println("✅ All documentation examples validated successfully")
          }
          
          func validateCodeBlocks(filePath string) error {
              content, err := os.ReadFile(filePath)
              if err != nil {
                  return err
              }
              
              // Find Go code blocks
              re := regexp.MustCompile("```go\n(.*?)\n```")
              matches := re.FindAllStringSubmatch(string(content), -1)
              
              for i, match := range matches {
                  if len(match) > 1 {
                      code := match[1]
                      if err := validateGoCode(code, fmt.Sprintf("%s:block_%d", filePath, i)); err != nil {
                          fmt.Printf("⚠️  Code validation warning in %s (block %d): %v\n", filePath, i, err)
                          // Warning only, don't fail the build
                      }
                  }
              }
              return nil
          }
          
          func validateGoCode(code, location string) error {
              // Skip examples that are intentionally incomplete
              if strings.Contains(code, "// Example:") || 
                 strings.Contains(code, "...") ||
                 strings.Contains(code, "// Implementation") {
                  return nil
              }
              
              // Try to parse as Go code
              fset := token.NewFileSet()
              _, err := parser.ParseFile(fset, location, "package main\nimport \"context\"\n"+code, parser.ParseComments)
              return err
          }
          EOF
          
          # Run validation
          go run validate-docs.go
          
      - name: Update version information
        run: |
          # Extract version from go.mod or git tags
          if [ -n "${{ github.ref_name }}" ] && [[ "${{ github.ref_name }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="main"
          fi
          
          # Update Hugo config with current version
          sed -i "s/version: .*/version: $VERSION/" docs/hugo.yaml
          
          # Update package version references in documentation
          find docs/content -name "*.md" -exec sed -i "s/go-plugins v[0-9.]*/go-plugins $VERSION/g" {} \;
          
      - name: Check documentation links
        run: |
          # Create link checker script
          cat > check-links.go << 'EOF'
          package main
          
          import (
              "fmt"
              "io/fs"
              "os"
              "path/filepath"
              "regexp"
              "strings"
          )
          
          func main() {
              var brokenLinks []string
              
              err := filepath.WalkDir("docs/content", func(path string, d fs.DirEntry, err error) error {
                  if err != nil || !strings.HasSuffix(path, ".md") {
                      return err
                  }
                  
                  content, err := os.ReadFile(path)
                  if err != nil {
                      return err
                  }
                  
                  // Find internal links [text](/path/)
                  re := regexp.MustCompile(`\[([^\]]+)\]\((/[^)]+/)\)`)
                  matches := re.FindAllStringSubmatch(string(content), -1)
                  
                  for _, match := range matches {
                      if len(match) > 2 {
                          link := match[2]
                          if !checkInternalLink(link) {
                              brokenLinks = append(brokenLinks, fmt.Sprintf("%s: %s", path, link))
                          }
                      }
                  }
                  return nil
              })
              
              if err != nil {
                  fmt.Printf("Link check failed: %v\n", err)
                  os.Exit(1)
              }
              
              if len(brokenLinks) > 0 {
                  fmt.Println("⚠️  Broken internal links found:")
                  for _, link := range brokenLinks {
                      fmt.Printf("  %s\n", link)
                  }
                  // Warning only for now
              } else {
                  fmt.Println("✅ All internal links validated")
              }
          }
          
          func checkInternalLink(link string) bool {
              // Remove leading/trailing slashes and convert to file path
              cleanLink := strings.Trim(link, "/")
              if cleanLink == "" {
                  return true // Root link
              }
              
              // Check if corresponding file exists
              possiblePaths := []string{
                  filepath.Join("docs/content", cleanLink, "_index.md"),
                  filepath.Join("docs/content", cleanLink+".md"),
                  filepath.Join("docs/content", cleanLink, "index.md"),
              }
              
              for _, path := range possiblePaths {
                  if _, err := os.Stat(path); err == nil {
                      return true
                  }
              }
              return false
          }
          EOF
          
          # Run link checker
          go run check-links.go
          
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v3
        
      - name: Install Node.js dependencies
        run: "[[ -f package-lock.json || -f npm-shrinkwrap.json ]] && npm ci || true"
        working-directory: ./docs
        
      - name: Build with Hugo
        env:
          # For maximum backward compatibility with Hugo modules
          HUGO_ENVIRONMENT: production
          HUGO_ENV: production
        run: |
          cd docs
          hugo \
            --gc \
            --minify \
            --baseURL "${{ steps.pages.outputs.base_url }}/"
            
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v2
        with:
          path: ./docs/public

  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    permissions:
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v3
